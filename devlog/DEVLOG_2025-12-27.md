# Development Log - 2025-12-27

## Session Duration
~4 hours (full session - setup through Milestone 1 partial completion)

## Goals
- ✅ Complete Milestone 0: Environment Setup
- ✅ Set up Rust workspace structure
- ✅ Start Milestone 1: Math Library port (Ray and Interval)

## What I Did

### Environment Setup (Milestone 0 Complete!)
- ✅ Verified Rust 1.86.0 installation
- ✅ Created Cargo workspace with 4 crates:
  - `bif_math` - Math library (wraps glam)
  - `bif_core` - Core scene/primitive types
  - `bif_render` - Rendering engine
  - `bif_viewer` - Application entry point

### Workspace Configuration
- ✅ Configured workspace dependencies in root `Cargo.toml`
- ✅ Set up each crate with proper dependencies
- ✅ Used glam 0.29, wgpu 22.1, egui 0.29 (compatible with Rust 1.86)
- ✅ Added development profile with opt-level=1 for faster iteration
- ✅ Created basic tests for `bif_math` crate

### Git Repository Issue - Fixed!
- **Problem:** `cargo new` created nested `.git` directories in crates
- **Solution:** Manually created crate structure without `cargo new`
- **Verification:** Only ONE `.git` directory at workspace root
- ✅ Committed workspace setup to git

### Legacy Code Setup
- ✅ Copied Go raytracer to `legacy/go-raytracing/`
- ✅ Set up Git LFS for large files (.obj models, .hdr, .pprof, .usd files)
- ✅ Created `.gitattributes` with LFS tracking rules
- ✅ Committed legacy code as reference for porting

### Milestone 1: Math Library Porting

#### Ray Struct - Complete! ✅
- ✅ Ported `Ray` from Go to Rust
- ✅ Added constructor: `Ray::new(origin, direction, time)`
- ✅ Added getter methods: `origin()`, `direction()`, `time()`
- ✅ Added `at(t)` method for point-along-ray calculation
- ✅ Made Ray `Copy` trait (small, cheap to copy)
- ✅ Wrote comprehensive tests (6 tests, all passing)
- ✅ Documented with doc comments

**Key learning:** Direct field access vs getters - Rust allows both!

#### Interval Struct - Complete! ✅
- ✅ Ported `Interval` from Go to Rust
- ✅ Implemented all methods:
  - `new(min, max)` - Constructor
  - `size()` - Returns max - min
  - `contains(x)` - Inclusive check [min, max]
  - `surrounds(x)` - Exclusive check (min, max)
  - `clamp(x)` - Clamps value to interval
  - `expand(delta)` - Expands by delta/2 on each side
  - `add(other)` - Component-wise addition
- ✅ Added constants: `Interval::EMPTY`, `Interval::UNIVERSE`
- ✅ Wrote comprehensive tests (10 tests, all passing)
- ✅ Hand-typed code for learning (ask mode)

**Key learning:** Rust's `f32::clamp()` is cleaner than Go's if/else chain!

### Documentation
- ✅ Added devlog instructions to `CLAUDE.md`
- ✅ Created `devlog/README.md` with format guidelines

## Learnings

### Rust Concepts Mastered Today

1. **Workspace structure** - `resolver = "2"`, `members = [...]`
2. **Workspace inheritance** - `version.workspace = true` to share config
3. **Dependency management** - Centralized versions in `[workspace.dependencies]`
4. **Profile optimization** - `opt-level = 1` for dev builds speeds up iteration
5. **Method receivers:**
   - `&self` - Borrow (read-only, most common)
   - `self` - Take ownership (consumes the value)
   - `&mut self` - Mutable borrow (can modify fields)
6. **Copy trait** - Small types (Ray, Interval) can be copied implicitly
7. **Associated constants** - `pub const EMPTY: Interval = ...` in impl block
8. **Inline hints** - `#[inline]` for simple getters
9. **Doc comments** - `///` generates documentation
10. **Git LFS** - Tracking large binary files

### Go → Rust Translation Patterns

| Go | Rust | Notes |
|---|---|---|
| `type Ray struct { ... }` | `pub struct Ray { ... }` | Explicit pub |
| `func NewRay(...)` | `pub fn new(...) -> Self` | Constructor in impl |
| `func (r Ray) Method()` | `pub fn method(&self)` | Borrow by default |
| `r.Field` | `self.field` | Lowercase convention |
| `float64` | `f32` | Graphics standard |
| `math.Inf(1)` | `f32::INFINITY` | Built-in constant |
| `v.Add(u)` | `v + u` | Operator overloading |

### Common Pitfalls Avoided

- ❌ **Nested git repos** - `cargo new` creates `.git` in each crate
  - ✅ Fixed by manually creating directory structure
- ❌ **Version compatibility** - Rust 1.86 doesn't support latest egui/wgpu
  - ✅ Used compatible versions (egui 0.29, wgpu 22.1)
- ❌ **PascalCase method names** - Rust uses snake_case
  - ✅ Used `add()` not `Add()`
- ❌ **Missing doc comments** - Easy to forget
  - ✅ Added `///` comments for all public APIs

### Rust vs Go Observations

- Cargo workspaces are like Go modules with nested `go.mod` files
- Dependency version pinning is more explicit than Go's `go.mod`
- Tests live in the same file (`#[cfg(test)]` mod) vs separate `_test.go` files
- Rust's operator overloading makes math code cleaner (`v + u` vs `v.Add(u)`)
- Constants must be compile-time known (no dynamic initialization)
- Field shorthand: `Self { min, max }` like Go's `Ray{orig: orig}`

## Architecture Decisions

### Why glam instead of custom Vec3?
- SIMD-optimized (4x faster than naive implementation)
- Industry standard in Rust gamedev/graphics
- Proven in production (Bevy, Fyrox engines use it)
- Can always add custom wrappers if needed

### Why egui for prototyping?
- Pure Rust (no C++ FFI complexity)
- Immediate mode = fast iteration
- Will keep it as dev UI even when adding Qt later

### Crate Structure Rationale
- `bif_math` - Pure math, no dependencies → fastest compile times
- `bif_core` - Depends on math, used by all → stable API layer
- `bif_render` - Heavy wgpu dependencies → isolates GPU code
- `bif_viewer` - Application glue → can swap UI without touching core

### Why Public Fields on Ray/Interval?
- Simple data types (no invariants to maintain)
- Direct access is idiomatic for simple structs
- Added getter methods for API compatibility with Go
- Rust's type system prevents misuse anyway

## Next Session

### Immediate Tasks (Milestone 1 Continuation)
1. ✅ ~~Copy Go raytracer to `legacy/go-raytracing/`~~ DONE
2. ✅ ~~Port Ray struct~~ DONE
3. ✅ ~~Port Interval helper~~ DONE
4. ⏳ **Port AABB struct** - bounding box logic (NEXT!)
   - Most complex of the math types
   - Has ray intersection logic
   - Uses Interval internally
   - Estimated: 1-1.5 hours

### Estimated Time for Milestone 1 Completion
- ✅ Ray struct: ~45 min (DONE)
- ✅ Interval: ~30 min (DONE)
- ⏳ AABB struct: ~1-1.5 hours (REMAINING)
- **Total Progress: ~2/3 hours done, 1-1.5 hours remaining**

## Blockers/Issues
- None! Everything compiling and tests passing (16/16 tests green ✅)

## Notes
- Rust 1.86 is sufficient for now, can upgrade to 1.88+ later for latest deps
- devlog format working well - keeping this habit!
- Side project pace is realistic - no rush, steady progress
- Hand-typing code (ask mode) really helps internalize Rust patterns
- Git LFS setup will be useful for USD files later

## Stats
- **Files Created:** 3 (ray.rs, interval.rs, .gitattributes)
- **Tests Written:** 16 (all passing)
- **Commits Today:** 4
- **Lines of Code:** ~350 (excluding legacy Go code)

---

**Next session starts with:** Porting AABB struct (the final major math type for Milestone 1).
- Side project pace is realistic - no rush, steady progress

---

**Next session starts with:** Copying Go code to legacy/ and porting Ray struct.
