# Development Log - 2025-12-27

## Session Duration

~2 hours (setup and planning)

## Goals

- Complete Milestone 0: Environment Setup
- Set up Rust workspace structure
- Prepare for Milestone 1: Math Library port

## What I Did

### Environment Setup

- ✅ Verified Rust 1.86.0 installation
- ✅ Created Cargo workspace with 4 crates:
  - `bif_math` - Math library (wraps glam)
  - `bif_core` - Core scene/primitive types
  - `bif_render` - Rendering engine
  - `bif_viewer` - Application entry point

### Workspace Configuration

- ✅ Configured workspace dependencies in root `Cargo.toml`
- ✅ Set up each crate with proper dependencies
- ✅ Used glam 0.29, wgpu 22.1, egui 0.29 (compatible with Rust 1.86)
- ✅ Added development profile with opt-level=1 for faster iteration
- ✅ Created basic tests for `bif_math` crate

### Git Repository Issue - Fixed

- **Problem:** `cargo new` created nested `.git` directories in crates
- **Solution:** Manually created crate structure without `cargo new`
- **Verification:** Only ONE `.git` directory at workspace root
- ✅ Committed workspace setup to git

### Documentation

- ✅ Added devlog instructions to `CLAUDE.md`
- ✅ Created `devlog/README.md` with format guidelines

## Learnings

### Rust Concepts Encountered

1. **Workspace structure** - `resolver = "2"`, `members = [...]`
2. **Workspace inheritance** - `version.workspace = true` to share config
3. **Dependency management** - Centralized versions in `[workspace.dependencies]`
4. **Profile optimization** - `opt-level = 1` for dev builds speeds up iteration

### Common Pitfalls Avoided

- ❌ **Nested git repos** - `cargo new` creates `.git` in each crate
  - ✅ Fixed by manually creating directory structure
- ⚠️ **Version compatibility** - Rust 1.86 doesn't support latest egui/wgpu
  - ✅ Used compatible versions (egui 0.29, wgpu 22.1)

### Rust vs Go Observations

- Cargo workspaces are like Go modules with nested `go.mod` files
- Dependency version pinning is more explicit than Go's `go.mod`
- Tests live in the same file (`#[cfg(test)]` mod) vs separate `_test.go` files

## Architecture Decisions

### Why glam instead of custom Vec3?

- SIMD-optimized (4x faster than naive implementation)
- Industry standard in Rust gamedev/graphics
- Proven in production (Bevy, Fyrox engines use it)
- Can always add custom wrappers if needed

### Why egui for prototyping?

- Pure Rust (no C++ FFI complexity)
- Immediate mode = fast iteration
- Will keep it as dev UI even when adding Qt later

### Crate Structure Rationale

- `bif_math` - Pure math, no dependencies → fastest compile times
- `bif_core` - Depends on math, used by all → stable API layer
- `bif_render` - Heavy wgpu dependencies → isolates GPU code
- `bif_viewer` - Application glue → can swap UI without touching core

## Next Session

### Immediate Tasks (Milestone 1 Start)

1. **Copy Go raytracer to `legacy/go-raytracing/`**
2. **Port Ray struct** - origin + direction + methods
   - Read Go implementation
   - Translate to Rust
   - Understand `&self` vs `self` vs `&mut self`
   - Add tests
3. **Port AABB struct** - bounding box logic
4. **Port Interval helper** - min/max range

### Questions to Address

- Where is Go raytracer code on disk?
- Do we need all Go code or just math types?

### Estimated Time for Milestone 1

- Ray struct: ~30-45 min
- AABB struct: ~1-1.5 hours (more complex)
- Interval: ~20-30 min
- **Total: 2-3 hours over 1-2 sessions**

## Blockers/Issues

- None currently - environment working perfectly!

## Notes

- Rust 1.86 is sufficient for now, can upgrade to 1.88+ later for latest deps
- devlog format working well - keeping this habit!
- Side project pace is realistic - no rush, steady progress

---

**Next session starts with:** Copying Go code to legacy/ and porting Ray struct.
